// 일반적인 dp처럼 점화식을 찾아 단일배열로 해결하는 문제인줄 알았다.
// 그러나 아무리 봐도 점화식을 세울수 없었고 구글링을 하게 되었다.
// 검색을 해서 찾아보니 삼중 반복문 + dp를 이용하여 해결하는 문제였다. 
// 처음에 삼중 반복문으로 푼다는 말을 듣고 맨 바깥에는 시작 숫자, 두번째 반복문에는 끝나는 숫자, 맨 안쪽에는 나누는 위치로 두고 해결하려고 했다.
// 그러나 그렇게는 결국 해결할수 없었고 코드를 참고하였다.
// 코드의 양은 그렇게 많지 않았지만 동작과정이 생각보다 복잡해서 이해하기가 굉장히 어려웠다. 
// 아직도 완벽히 이해를 하지 못해서 나중에 천천히 더 살펴봐야할 것이다.

#include<iostream>
#include<algorithm>
using namespace std;

int dp[501][501]={0};
int sum[501]={0};

int main(){
    int T,K,num;
    cin>>T;
    for(int i=0;i<T;i++){
        cin>>K;
        for(int j=1;j<=K;j++){
            cin>>num;
            sum[j]=sum[j-1]+num;
        }
        for(int a=1;a<K;a++){ // 더하는 수의 범위(1이면 1~2, 2~3 / 2면 1~3, 2~4를 계산하는 식임)
            for(int b=1;b<=K-a;b++){ // 시작 숫자
                dp[b][a+b]=1000000000; // 최솟값을 구해야하기 때문에 큰 값으로 초기화를 해줌
                for(int m=b;m<a+b;m++){ // 나누는 위치
                    dp[b][a+b]=min(dp[b][a+b],dp[b][m]+dp[m+1][a+b]+sum[a+b]-sum[b-1]);
                }
            }
        }
        cout<<dp[1][K]<<"\n";
    }
}